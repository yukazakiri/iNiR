#!/usr/bin/env python3
"""Generate Spicetify color.ini from Material You colors.

This script reads the Material You color palette generated by Quickshell's
wallpaper pipeline and produces a color.ini file for Spicetify theming.

Reads:  ~/.local/state/quickshell/user/generated/colors.json
Writes: ~/.config/spicetify/Themes/ii-material/color.ini
        ~/.config/spicetify/Themes/ii-material/user.css (minimal styling)

Usage: Run this script after wallpaper change to sync Spicetify colors.
       Then manually apply: spicetify config current_theme ii-material && spicetify apply
"""

from __future__ import annotations

import json
import os
from colorsys import rgb_to_hls, hls_to_rgb
from pathlib import Path
from typing import Dict, Tuple


COLOR_SOURCE = Path(
    os.environ.get(
        "QUICKSHELL_COLORS_JSON",
        "~/.local/state/quickshell/user/generated/colors.json",
    )
).expanduser()

OUTPUT_DIR = Path(
    os.environ.get(
        "SPICETIFY_THEME_DIR",
        "~/.config/spicetify/Themes/ii-material",
    )
).expanduser()

COLOR_INI = OUTPUT_DIR / "color.ini"
USER_CSS = OUTPUT_DIR / "user.css"


def _ensure_parent(path: Path) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)


def _load_colors() -> Dict[str, str]:
    if not COLOR_SOURCE.exists():
        raise FileNotFoundError(
            f"Material colors file not found: {COLOR_SOURCE}. "
            "Ensure switchwall.sh has been executed successfully."
        )
    with COLOR_SOURCE.open("r", encoding="utf-8") as fh:
        data = json.load(fh)
    return {k: v.lower() for k, v in data.items()}


def _hex_to_rgb(color: str) -> Tuple[int, int, int]:
    color = color.lstrip("#")
    return tuple(int(color[i : i + 2], 16) for i in range(0, 6, 2))


def _rgb_to_hex(rgb) -> str:
    r, g, b = (max(0, min(int(round(v)), 255)) for v in rgb)
    return f"#{r:02x}{g:02x}{b:02x}"


def _adjust_lightness(color: str, delta: float) -> str:
    r, g, b = (c / 255.0 for c in _hex_to_rgb(color))
    h, l, s = rgb_to_hls(r, g, b)
    l = max(0.0, min(1.0, l + delta))
    r2, g2, b2 = hls_to_rgb(h, l, s)
    return _rgb_to_hex((r2 * 255, g2 * 255, b2 * 255))


def _is_dark_mode(colors: Dict[str, str]) -> bool:
    background = colors.get("background", "#ffffff")
    r, g, b = _hex_to_rgb(background)
    h, l, s = rgb_to_hls(r / 255, g / 255, b / 255)
    return l < 0.5


def _build_spicetify_palette(colors: Dict[str, str], dark: bool) -> Dict[str, str]:
    """Build Spicetify color palette from Material You colors.

    Args:
        colors: Material You color dictionary
        dark: If True, generate dark theme; if False, generate light theme
    """

    primary = colors.get("primary", "#1db954")
    tertiary = colors.get("tertiary", "#1db954")
    error = colors.get("error", "#e22134")
    inverse_primary = colors.get("inverse_primary", "#1db954")

    if dark:
        surface = colors.get("surface", "#121212")
        surface_low = colors.get("surface_container_low", "#121212")
        surface_std = colors.get("surface_container", "#181818")
        surface_high = colors.get("surface_container_high", "#282828")
        on_surface = colors.get("on_surface", "#ffffff")
        on_surface_variant = colors.get("on_surface_variant", "#b3b3b3")
        outline = colors.get("outline", "#b3b3b3")
        outline_variant = colors.get("outline_variant", "#535353")
        primary_container = colors.get("primary_container", "#1db954")
        shadow = colors.get("shadow", "#000000")
        is_currently_dark = _is_dark_mode(colors)
        if not is_currently_dark:
            surface = colors.get("inverse_surface", "#121212")
            surface_low = colors.get("inverse_surface", "#121212")
            surface_std = colors.get("inverse_surface", "#181818")
            surface_high = _adjust_lightness(
                colors.get("inverse_surface", "#282828"), 0.05
            )
            on_surface = colors.get("inverse_on_surface", "#ffffff")
            on_surface_variant = _adjust_lightness(
                colors.get("inverse_on_surface", "#b3b3b3"), -0.1
            )
            outline = _adjust_lightness(
                colors.get("inverse_on_surface", "#b3b3b3"), -0.2
            )
            outline_variant = _adjust_lightness(
                colors.get("inverse_on_surface", "#535353"), -0.1
            )
            primary_container = colors.get("inverse_primary", "#1db954")
    else:
        is_currently_dark = _is_dark_mode(colors)
        if is_currently_dark:
            surface = colors.get("inverse_surface", "#ffffff")
            surface_low = colors.get("inverse_surface", "#ffffff")
            surface_std = colors.get("inverse_surface", "#f5f5f5")
            surface_high = _adjust_lightness(
                colors.get("inverse_surface", "#e8e8e8"), -0.02
            )
            on_surface = colors.get("inverse_on_surface", "#000000")
            on_surface_variant = _adjust_lightness(
                colors.get("inverse_on_surface", "#333333"), 0.1
            )
            outline = _adjust_lightness(
                colors.get("inverse_on_surface", "#666666"), 0.2
            )
            outline_variant = _adjust_lightness(
                colors.get("inverse_on_surface", "#999999"), 0.1
            )
            primary_container = colors.get("inverse_primary", "#1db954")
        else:
            surface = colors.get("surface", "#ffffff")
            surface_low = colors.get("surface_container_low", "#ffffff")
            surface_std = colors.get("surface_container", "#f5f5f5")
            surface_high = colors.get("surface_container_high", "#e8e8e8")
            on_surface = colors.get("on_surface", "#000000")
            on_surface_variant = colors.get("on_surface_variant", "#333333")
            outline = colors.get("outline", "#666666")
            outline_variant = colors.get("outline_variant", "#999999")
            primary_container = colors.get("primary_container", "#1db954")
        shadow = colors.get("shadow", "#000000")

    palette: Dict[str, str] = {}

    palette["text"] = on_surface.lstrip("#")
    palette["subtext"] = on_surface_variant.lstrip("#")
    palette["main"] = surface.lstrip("#")
    palette["main-elevated"] = surface_std.lstrip("#")
    palette["highlight"] = _adjust_lightness(primary, 0.1 if dark else -0.1).lstrip("#")
    palette["highlight-elevated"] = _adjust_lightness(
        primary, 0.15 if dark else -0.15
    ).lstrip("#")
    palette["sidebar"] = surface_low.lstrip("#")
    palette["player"] = surface_std.lstrip("#")
    palette["card"] = surface_high.lstrip("#")
    palette["shadow"] = shadow.lstrip("#")
    palette["selected-row"] = primary_container.lstrip("#")
    palette["button"] = primary.lstrip("#")
    palette["button-active"] = _adjust_lightness(
        primary, 0.05 if dark else -0.05
    ).lstrip("#")
    palette["button-disabled"] = outline_variant.lstrip("#")
    palette["tab-active"] = primary_container.lstrip("#")
    palette["notification"] = tertiary.lstrip("#")
    palette["notification-error"] = error.lstrip("#")
    palette["misc"] = outline.lstrip("#")

    return palette


def _build_color_ini(colors: Dict[str, str]) -> str:
    """Generate color.ini content with both dark and light schemes."""

    dark_palette = _build_spicetify_palette(colors, dark=True)
    light_palette = _build_spicetify_palette(colors, dark=False)

    lines = [
        "; Auto-generated by iNiR from Material You colors",
        "; Apply with: spicetify config current_theme ii-material && spicetify apply",
        "",
        "[material-dark]",
    ]

    for key in [
        "text",
        "subtext",
        "main",
        "main-elevated",
        "highlight",
        "highlight-elevated",
        "sidebar",
        "player",
        "card",
        "shadow",
        "selected-row",
        "button",
        "button-active",
        "button-disabled",
        "tab-active",
        "notification",
        "notification-error",
        "misc",
    ]:
        lines.append(f"{key} = {dark_palette.get(key, 'ffffff')}")

    lines.extend(["", "[material-light]"])

    for key in [
        "text",
        "subtext",
        "main",
        "main-elevated",
        "highlight",
        "highlight-elevated",
        "sidebar",
        "player",
        "card",
        "shadow",
        "selected-row",
        "button",
        "button-active",
        "button-disabled",
        "tab-active",
        "notification",
        "notification-error",
        "misc",
    ]:
        lines.append(f"{key} = {light_palette.get(key, '000000')}")

    return "\n".join(lines)


def _build_user_css() -> str:
    """Generate minimal user.css for Material Design styling."""

    return """/* iNiR Material - Minimal Material Design styling for Spicetify */

/* Rounded corners for cards and buttons */
.main-card-card,
.main-button-button,
.x-categoryCard-CategoryCard {
    border-radius: 12px !important;
}

/* Smoother transitions */
*:not([class*="progress"]) {
    transition: background-color 0.2s ease, border-color 0.2s ease;
}
"""


def main() -> None:
    try:
        colors = _load_colors()
    except FileNotFoundError as exc:
        print(f"Error: {exc}")
        return

    _ensure_parent(COLOR_INI)

    color_ini_content = _build_color_ini(colors)
    with COLOR_INI.open("w", encoding="utf-8") as fh:
        fh.write(color_ini_content)
    print(f"Generated: {COLOR_INI}")

    user_css_content = _build_user_css()
    with USER_CSS.open("w", encoding="utf-8") as fh:
        fh.write(user_css_content)
    print(f"Generated: {USER_CSS}")

    dark = _is_dark_mode(colors)
    scheme = "material-dark" if dark else "material-light"
    print(
        f"\nTo apply: spicetify config current_theme ii-material color_scheme {scheme} && spicetify apply"
    )


if __name__ == "__main__":
    main()
